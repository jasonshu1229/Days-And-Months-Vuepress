---
title: 作用域闭包
date: 2022-08-31 22:10:43
permalink: /pages/2031fa/
---

## 闭包

###### 来自红宝书的定义：

匿名函数经常被人误认为是闭包。**闭包**指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中产生的。

###### 来自MDN对JavaScript闭包的解释：

一个函数和对其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用保卫），这样的组合就是**闭包**。
- **闭包**让开发者可以在一个内层函数中访问到其他外层函数的作用域；
- 在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；

###### 来自《你不知道的JavaScript》里的解释：

当函数可以被记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。

接下来看一段代码，清晰地展示了闭包：

```js
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();
baz(); // 2 这就是闭包的效果
```

函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当做一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。

bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。



<b>定义：</b>它是函数运行时候所产生的的**机制**，函数执行会形成一个全新的私有上下文，可以保护里面的私有变量和外界互不干扰(保护机制）<br>
<b>大家认为：</b>需要当前上下文不能被出栈释放，这样的私有变量及它的值也不会被释放掉(保存机制)<br><br>
<b>面试：</b>函数执行形成一个私有的上下文，如果当前上下文的私有变量，有被外界所占用，那么当前私有上下文就不能出栈释放，自然而然里面的私有变量被保存保护起来了，不被外界干扰，操作里面的变量**不会影响外界**，这种机制叫闭包<br><br>
<b>作用：</b>保存和保护


::: tip ++i / i++
let i = 10; <br><br>
<b>i++</b>：sum = 5+(i++); 先计算，再累加 (sum = 5+10; i = 11)<br>
<b>++i</b>：sum = 5+(++i); 先累加，再计算 (sum = 5+11; i = 11)
:::

<b>解题思路</b>
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gha699418vj314g0esdi1.jpg)

<b>经典例题3</b>

``` js
let a=0,
    b=0;
function A(a){
  A=function(b){
      alert(a+b++);
  };
  alert(a++);
}
A(1);
A(2);
```

<b>解题思路</b>
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gha810v2wdj31gm0sa41l.jpg)

## 内存优化

<b>栈内存（执行上下文）</b>：<br><br>
一般情况下，函数执行完，所形成的上下文会被出栈释放掉。<br>
特殊情况：当前上下文中某些内容被上下文以外的食物占用了，此时不能出栈释放<br>
全局上下文：加载页面创建的，也是只有页面关闭才会被释放掉。
<br><br>
<b>堆内存的垃圾回收机制</b>：<br><br>
1、引用计数（IE为主）：在某些情况下会导致计数混乱，这样会造成内存不能被释放（内存泄漏）<br>
2、检测引用(占用)/标记清除（谷歌为主）：浏览器在空闲时候会依次检测所有的堆内存，把没有被任何事物占用的内存释放掉，以此来优化内存。<br><br>
手动释放内存，其实就是解除占用（手动赋值为null即可）

## 闭包好不好？

大量应用闭包肯定会导致内存的泄漏，但是闭包保护和保存作用，在真实开发中我们还是需要的，所以需要学会“合理使用闭包”

## 闭包的应用：

ECStack/EC/AO/VO/SCOPE/SCOPE-CHAIN/

1、实战用途<br>
2、高阶变成：柯理化/惰性函数/componse函数/释放不释放/垃圾回收机制<br>
3、源码分析：JQ/Lodash/React(Redux/高阶组件/Hooks)... <br>
4、自己封装插件组件的时候
