---
title: 闭包作用域
date: 2022-08-31 22:10:43
permalink: /pages/2031fa/
---

## 闭包

> **来自红宝书的定义：**

匿名函数经常被人误认为是闭包。**闭包**指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中产生的。

> **来自MDN对JavaScript闭包的解释：**

一个函数和对其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用保卫），这样的组合就是**闭包**。
- **闭包**让开发者可以在一个内层函数中访问到其他外层函数的作用域；
- 在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；

> **来自《你不知道的JavaScript》里的解释：**

当函数可以被记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。

接下来看一段代码，清晰地展示了闭包：

```js
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();
baz(); // 2 这就是闭包的效果
```

函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当做一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。

bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。

**bar()** 依然持有对 foo() 作用域的引用，而这个引用就叫作**闭包**。

可见闭包是由两部分组成的。

### 个人理解的闭包

<mark>一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包</mark>。

- 闭包首先是一个函数；
- 其次它可以访问外层作用域的自由变量；

### 闭包的其它理解

它也是函数运行时候所产生的的机制，函数执行会形成一个全新的私有上下文，可以保护里面的私有变量和外界互不干扰。

函数执行形成一个私有的上下文，如果当前上下文的私有变量，有被外界所占用，那么当前私有上下文就不能出栈释放，自然而然里面的私有变量被保存保护起来了，不被外界干扰，操作里面的变量**不会影响外界**，这种机制叫**闭包**。

### 图解闭包的执行过程

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5w73wc38zj21i40u0jvr.jpg" />
:::

上图虽然展示了闭包函数的执行过程，但完全没有体现出闭包的性质特点。

函数执行结束之后

<mark>函数执行完毕之后，baz() 销毁，进而导致 bar() 函数销毁，所以 bar() 的上下文和变量对象都会被销毁</mark>（可对照上面的流程图发现执行上文和变量对象均被销毁）。

最终的流程如图所示：

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5w7lsulf3j21ih0u0wij.jpg" />
:::

### 闭包的内存泄漏

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以自然地考虑对其进行回收。

<mark>而闭包的神奇之处正是可以阻止这件事情的发生</mark>。事实上 foo() 内部作用域依然存在，因为在 bar() 函数内依然持有对该作用域的引用，在查找 **变量a** 的时候会先在 bar() 自己的AO对象中查找，找不到，则会通过作用域链找到 **parentScope** 中的 foo 变量对象，而这个引用就叫作闭包。

所以我们常说的闭包会造成的内存泄漏，其实就是指作用域链中的 foo() 变量对象AO 地址没有办法在堆内存中被释放。

### 合理解决内存泄漏

将 baz() 的指针指向 null，就不对 foo 对象有引用，那么 foo 对应的 AO 对象就不可达了。在下一次的GC的检测中，它们就会被销毁掉。

```JS
baz = null;
```

当 baz 赋值为 null 后，会发生什么，如图所示：

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5w7ykx4uvj21bm0qcwgt.jpg" />
:::

```JS
baz = null;
foo = null;
```

如果希望内存彻底干净的话，也可以把 foo 赋值为 null。

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5w83c20rgj20vi0e0dgo.jpg" style="zoom:50%;" />
:::


::: tip ++i / i++
let i = 10; <br><br>
<b>i++</b>：sum = 5+(i++); 先计算，再累加 (sum = 5+10; i = 11)<br>
<b>++i</b>：sum = 5+(++i); 先累加，再计算 (sum = 5+11; i = 11)
:::

<b>解题思路</b>
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gha699418vj314g0esdi1.jpg)

<b>经典例题3</b>

``` js
let a=0,
    b=0;
function A(a){
  A=function(b){
      alert(a+b++);
  };
  alert(a++);
}
A(1);
A(2);
```

<b>解题思路</b>
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gha810v2wdj31gm0sa41l.jpg)

## 内存优化

<b>栈内存（执行上下文）</b>：<br><br>
一般情况下，函数执行完，所形成的上下文会被出栈释放掉。<br>
特殊情况：当前上下文中某些内容被上下文以外的食物占用了，此时不能出栈释放<br>
全局上下文：加载页面创建的，也是只有页面关闭才会被释放掉。
<br><br>
<b>堆内存的垃圾回收机制</b>：<br><br>
1、引用计数（IE为主）：在某些情况下会导致计数混乱，这样会造成内存不能被释放（内存泄漏）<br>
2、检测引用(占用)/标记清除（谷歌为主）：浏览器在空闲时候会依次检测所有的堆内存，把没有被任何事物占用的内存释放掉，以此来优化内存。<br><br>
手动释放内存，其实就是解除占用（手动赋值为null即可）

## 闭包好不好？

大量应用闭包肯定会导致内存的泄漏，但是闭包保护和保存作用，在真实开发中我们还是需要的，所以需要学会“合理使用闭包”

## 闭包的应用：

ECStack/EC/AO/VO/SCOPE/SCOPE-CHAIN/

1、实战用途<br>
2、高阶变成：柯理化/惰性函数/componse函数/释放不释放/垃圾回收机制<br>
3、源码分析：JQ/Lodash/React(Redux/高阶组件/Hooks)... <br>
4、自己封装插件组件的时候
