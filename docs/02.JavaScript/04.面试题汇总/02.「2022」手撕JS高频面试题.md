---
title: 「2022」手撕JS高频面试题
date: 2022-09-07 17:20:33
permalink: /pages/7d69ea/
---

### 1. 实现检测数据类型的通用方法

```js
// Object.prototype.toString是一步到位的
function getType(object) {
  return Object.prototype.toString.call(object).slice(8, -1).toLowerCase();
}

getType({}); // object
getType("a"); // string
getType(1); // number
getType(true); // boolean
getType(null); // null
getType(undefined); // undefined
getType(Symbol("a")); // symbol
getType(11n); // bigint
getType(/a/); // regexp
getType(new Date()); // date
getType([0, 1, 2]); // array
getType(function () {}); // function
getType(new Error()); // error
getType(new Map()); // map
getType(new Set()); // set
```

### 2. 手动实现call方法

```js
/**
 * thisArg： 要改变的函数中的this指向
 * args：传递给要被执行的函数的实参信息
 * this：要被执行的函数
 */
Function.prototype._call = function(thisArg, ...args) {
  // 获取需要被执行的函数
  var fn = this;

  // 对 thisArg转成对象类型（防止传入的是非对象类型）
  thisArg = (thisArg !== null && this !== undefined) ? Object(thisArg) : window;

  // 调用需要被执行的函数
  thisArg.fn = fn;
  var result = this.fn(...args);
  delete thisArg.fn;

  // 将结果返回
  return result;
}
```

**测试用例：**

```js
function sum(num1, num2) {
  console.log(this, num1, num2)
  return num1 + num2;
}

function foo() {
  console.log(this);
}

var result = sum._call('abc', 10, 20); // String {'abc', fn: ƒ} 20 30
foo._call(undefined); // window
```

### 3.手动实现apply方法

```js
/**
 * thisArg： 要改变的函数中的this指向
 * argArray：传递给要被执行的函数的实参信息(数组形式)
 * this：要被执行的函数
 */
Function.prototype._apply = function(thisArg, argArray) {
  // 获取需要被执行的函数
  var fn = this;

  // 处理绑定的thisArg
  thisArg = (thisArg !== null && thisArg !== undefined) ? Object(thisArg) : window;

  // 执行函数
  thisArg.fn = fn;

  // 防止不传第二个参数时，argArray 为undefined报错
  argArray = argArray || []; 
  var result = thisArg.fn(...argArray);
  delete thisArg.fn;

  return result;
}
```

**测试用例：**
```js
function sum(num1, num2) {
  return num1 + num2;
}

function foo(num) {
  return num;
}

var result = sum._apply("abc", [20, 30]); // String {'abc', fn: ƒ} 50
var result2 = foo._apply("abc", [20]); // String {'abc', fn: ƒ} 20
```

### 4. 手动实现bind方法

```JS
Function.prototype._bind = function(thisArg, ...argArray) {
  // 获取到需要被执行的函数
  var fn = this;

  // 处理绑定的thisArg
  thisArg = (thisArg !== null && thisArg !== undefined) ? Object(thisArg) : window;

  return function(...args) {
    // 将函数放到thisArg中调用
    thisArg.fn = fn;
    // 合并参数
    var finalArgs = [...argArray, ...args];
    var result = thisArg.fn(...finalArgs);
    delete thisArg.fn;

    return result;
  }
}
```

**测试用例：**
```js
function foo() {
  console.log("foo被执行", this);
  return 20;
}

function sum(num1, num2, num3, num4) {
  console.log(num1, num2, num3, num4);
}

var bar = foo.hybind("abc"); // foo被执行 String {'abc', fn: ƒ}
var result = bar(); // 20

var newSum = sum.hybind("abc", 10, 20); // 10 20 30 40
var result = newSum(30, 40);
```

### 5. 手动实现自动柯里化函数

```js
/**
 * fn：要执行的函数
 */
function _curry(fn) {
  return function currying(...args) {
    // 判断当前已经接收的参数个数，判断是一次性全部传入还是分批传入的
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      // 分批传入参数时，需要返回一个新的函数，接收剩余的参数
      return function(...restArgs) {
        // 很有可能不能在参数分为很多步传入，所以需要递归调用currying来检查参数是否全部传进去
        return currying.apply(this, args.concat(restArgs));
      }
    }
  }
}
```

**测试用例：**
```js
function add(x, y, z) {
  return x + y + z;
}

var curryAdd = _curry(add)
curryAdd(10, 20, 30); // 对应第一个if条件

// 等同于
curryAdd(10,20)(30);
curryAdd(10)(20)(30);
```

### 6. 手动实现组合函数

**思路：**
1. 判断传进来的参数是不是函数类型
2. 判断函数类型参数是否有值
  - 有值的话，执行`第一个函数`类型的参数，然后依次执行，返回结果；
  - 没值的话，直接传递要返回函数的参数；

```JS
function _compose(...fns) {
  var length = fns.length;
  for (var i = 0; i < length; i++) {
    if (typeof fns[i] !== 'function') {
      throw new TypeError("Expected arguments are functions")
    }
  }

  return function compose(...args) {
    var index = 0;
    var result = length ? fns[index].apply(this, args) : args;
    while(++index <length) {
      result = fns[index].call(this, result);
    }
    return result
  }
}
```

**测试用例：**

```JS
function double(m) {
  return m * 2
}

function square(n) {
  return n ** 2
}

var newFn = _compose(double, square)
console.log(newFn(10)) // 400
```

### 7. 判断两个对象内容是否一致

**思路：遍历对象的所有键名和键值是否都一致**
1. 判断两个对象是否指向同一内存
2. 使用 Object.getOwnPropertyNames 获取对象所有键名数组
3. 判断两个对象的键名数组长度是否相等
4. 遍历键名，判断键值是否都相等

```js
let obj1 = {
  a: 1,
  b: { c: 2 }
}

let obj2 = {
  b: { c : 3},
  a: 1
}
```

判断 obj1 和 obj2 属性属性值是否相同

```js
/**
 * 判断两个对象内容是否一致
 * @param {*} a obj1
 * @param {*} b obj2
 */
function isObjectValueEqual(a, b) {
  if (Object.is(a, b)) return true;
  let aProps = Object.getOwnPropertyNames(a);
  let bProps = Object.getOwnPropertyNames(b);
  // 对象键名数组长度都不一致，直接返回 false
  if (aProps.length !== bProps.length) return false;
  for (let prop in a) {
    // 判断 a 的键值，在 b 中是否存在，不存在，返回 false
    if (b.hasOwnProperty(prop)) {
      if (typeof a[prop] === 'object') {
        if (!isObjectValueEqual(a[prop], b[prop])) return false;
      } else if (a[prop] !== b[prop]) {
        return false;
      }
    } else {
      return false;
    }
  }
  return true;
}

console.log(isObjectValueEqual(obj1, obj2)); // false
```