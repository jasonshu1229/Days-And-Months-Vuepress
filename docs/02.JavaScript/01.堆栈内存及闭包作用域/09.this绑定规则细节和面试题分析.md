---
title: this绑定规则细节和面试题分析
date: 2022-09-06 23:38:28
permalink: /pages/5d683c/
---

在常见的编程语言中，几乎都有 this 这个关键字，但是 JavaScript 中的 this 和常见的面向对象语言的中的 this 不太一样。它们主要表现在以下几个方面：

- 常见面向对象的编程语言中，比如Java、C++、Swift等等一系列语言中，this 通常只会出现在类的方法中。也就是开发者需要定义 一个类，类中的方法（特别是实例方法）中，this 代表的是当前的调用对象。

- 但是在 JavaScript 中，this 关键字是其语言中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的的作用域中。

## 为什么需要this

试着编写一个 obj 对象，看看有 this 和没有 this 的区别：
```JS
// 无this
var obj = {
  name: "jasonshu",
  eating: function() {
    console.log(obj.name + "在吃东西")
  },
  running: function() {
    console.log(obj.name + "在跑步")
  },
  studying: function() {
    console.log(obj.name + "在学习")
  }
}

obj.eating()
obj.running()
obj.studying()
```

没有的 this 的时候，一旦当变量名改变，在对象内部方法调用的时候，发现使用原有变量名的地方都要跟着改变，会很麻烦。

```js
// 有this
var obj = {
  name: "jasonshu",
  eating: function() {
    console.log(this.name + "在吃东西")
  },
  running: function() {
    console.log(this.name + "在跑步")
  },
  studying: function() {
    console.log(this.name + "在学习")
  }
}

obj.eating()
```

从某些角度来说，开发中如果没有 this，很多的问题也会有解决方案。但是没有 this，会让我们编写代码变得很麻烦。


## this指向的规则

先从最开始的开始，this 在全局作用域下指向什么？

### this在全局中的指向

this 在浏览器中指向的是 window，而在 Node 环境下指的是 {}。

```js
console.log(this); // window

var name = 'jasonshu';
console.log(this.name); // jasonshu
console.log(window.name); // jasonshu
```

但是在开发中很少直接在全局作用域下去使用 this，通常**都是在函数中使用**。

之前提到所有的函数在被调用时，都会创建一个函数执行上下文，在这个上下文中记录着函数的调用栈、AO对象等，this 也是其中的一条记录。

### this的绑定规则

先来看一个比较困惑的问题，定义一个函数，对它采用三种不同方式的调用，产生了三种不同的结果。

```js
function foo() {
  console.log(this);
}

// 1. 直接调用函数
foo(); // window

// 2. 将foo放到一个对象中调用
var obj = {
  name: 'jasonshu',
  foo: foo
}

obj.foo(); // obj对象

// 3. 通过call/apply调用
foo.apply('abc'); // [String: 'abc']
```

通过上面的案例可以发现：

函数在调用时，JavaScript会默认给 this 绑定一个值。<mark>this 是在函数运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。</mark>

再声明一次：**this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式**。

this 绑定有四种规定：
- 方式一：默认绑定；
- 方式二：隐式绑定；
- 方式三：显示绑定；
- 方式四；new绑定；

#### 规则一：默认绑定

当函数被独立调用时，被称为默认绑定。独立的函数调用可以理解**函数没有被绑定到某个对象上进行调用**。

通过下面的几个案例看一下，常见的默认绑定：

```js
// 案例一：
function foo() {
  console.log(this)
}

foo() // window
```

```js
// 案例二：
function foo1() {
  console.log(this)
}

function foo2() {
  console.log(this)
  foo1()
}

function foo3() {
  console.log(this)
  foo2()
}

foo3() // window
```

```js
// 案例三：
var obj = {
  name: "why",
  foo: function() {
    console.log(this)
  }
}

var bar = obj.foo
bar() // window
```

```js
// 案例四：
function foo() {
  console.log(this)
}
var obj = {
  name: "why",
  foo: foo
}

var bar = obj.foo
bar() // window
```

#### 规则二：隐式绑定

当函数是**通过某个对象进行调用时**被称为隐式绑定。也就是它的调用位置中，是通过某个对象发起的函数调用。

通过下面的几个案例看一下，常见的隐式绑定：
```JS
// 案例一：
function foo() {
  console.log(this)
}

var obj = {
  name: "why",
  foo: foo
}

obj.foo() // obj对象
```
obj对象会被js引擎绑定到 fn 函数的中 this 里面。

```JS
// 案例二：
var obj = {
  name: "why",
  eating: function() {
    console.log(this.name + "在吃东西")
  },
  running: function() {
    console.log(obj.name + "在跑步")
  }
}

obj.eating(); // why在吃东西
```

```JS
// 案例三：
var obj1 = {
  name: "obj1",
  foo: function () {
    console.log(this);
  },
};

var obj2 = {
  name: "obj2",
  bar: obj1.foo,
};

obj2.bar();
```

隐式绑定有一个前提条件：

必须在调用的对象内部有一个对函数的引用（例如一个属性），如果没有这样的引用，在进行调用时，会报找不到该函数的错误。正是通过这个引用，间接的将 this 绑定到了这个对象上。

#### 规则三：显示绑定

如果不希望在**对象内部**包含这个函数的引用，同时又因希望在这个对象上进行强制调用，那么就需要 JavaScript 给我们提供的 call 和 apply 方法。

JavaScript 所有的函数都可以使用它们，这两个函数的第一个参数都要求是一个对象，在调用这个函数时，会将 this 绑定到这个传入的对象上。

因为上面的过程，我们明确的绑定了 this 指向的对象，所以称之为**显示绑定**。

通过下面的几个案例看一下，常见的显示绑定：
```JS
function foo() {
  console.log("函数被调用了", this)
}

var obj = {
  name: "obj",
};

foo.call(obj); // 函数被调用了 { name: 'obj' }
foo.apply(obj); // 同上
foo.apply("aaaa"); // 函数被调用了 [String: 'aaaa']
```

call 和 apply 的区别：
```JS
function sum(num1, num2, num3) {
  console.log(num1 + num2 + num3, this)
}

sum.call("call", 20, 30, 40);
sum.apply("apply", [20, 30, 40]);

```

#### 规则四：new绑定

new 关键字可以把 JavaScript 中的函数当做一个类的构造函数来使用。

使用 new 关键字调用函数时，会在内部执行以下操作：
- 创建一个全新的对象；
- 这个新对象会被执行 prototype 链接；
- 这个新对象会绑定到函数调用的this上；
- 如果函数没有返回其他对象，表达式会返回这个新对象；

```JS
function Person(name, age) {
  this.name = name
  this.age = age
}

var p1 = new Person("why", 18)
console.log(p1.name, p1.age) // why 18

var p2 = new Person("kobe", 30)
console.log(p2.name, p2.age) // kobe 30


var obj = {
  foo: function() {
    console.log(this)
  }
}
```
