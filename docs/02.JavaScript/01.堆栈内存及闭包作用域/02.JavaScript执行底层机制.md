---
title: JavaScript执行底层机制
date: 2022-08-31 17:04:43
permalink: /pages/a8732d/
article: false
---

## JS运行原理初探

假如现在有一段极为简单的代码，让我们看一下它是如何运行：

```JS
var a = 2;
```

为了能更好理解 JavaScript 的工作原理，需要开始像引擎（和它的朋友们）一样思考。

介绍引擎的和它的两个好朋友：

- **引擎：** 从头到尾负责整个 JavaScript 程序的编译及执行过程；
- **编译器：** 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（负责词法分析那些东西）；
- **作用域：** 引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量、函数、属性或函数参数的名称，例如上面的变量 a）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
  
当看见 var a = 2；这段程序时，引擎认为这里有两个完全不同的声明，<mark>一个由编译器在编译时处理、另一个则由引擎在运行时处理</mark>。

::: theorem 词法/语法分析阶段
编译器首先会将这段程序分解成词法单元（token），然后将词法单元解析成一个AST抽象语法树结构。
:::

::: theorem 代码生成阶段
编译器遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。
- 如果是，编译器会忽略该声明，继续向下编译；
- 否则它会要求在当前作用域声明一个新的变量，并命名为 a；

接下来编译器会为**引擎生成运行时所需的代码**，这些代码被用来处理 a = 2；这个赋值操作。引擎运行时首先会询问作用域，在当前作用域集合中是否存在 a 这个变量。
- 如果是，引擎就用这个变量；
- 如果否，引擎会继续查找该变量；
:::

最终没找到的话，引擎会抛出一个异常！

**总结：** 变量的赋值操作会执行两个动作，首先编译器会在当前作用域声明一个变量，然后在运行时引擎就查找它，如果能找到就对它赋值。


## 执行上下文与作用域

假如有下面👇🏻这段代码，它会在什么样的宿主环境下被执行呢？

### 全局代码的执行过程(无函数)

```JS
var name = "jason"

console.log(num1)

var num1 = 20;
var num2 = 30;
var result = num1 + num2;

console.log(result)
```

##### 1.解析代码阶段：

> JS引擎会在执行代码之前，在堆内存中创建一个全局对象：Global Object（GO）

**在堆内存中创建一个全局对象：Global Object（GO）：**

- GO对象可以被 **所有的作用域（scope）** 访问；
- 里面会包含**Date、Array、String、Number、setTimeout、setInterval**等等；
- 还有一个**window属性**指向自己；

在解析阶段，会找到全局定义的变量，提升到最顶端，赋值为 undefined。

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5usvmcjfzj20gk0cqaaj.jpg" style="zoom:50%;" />
:::

##### 2. 执行代码阶段：

- **执行上下文栈（Execution Context Stack）:** V8引擎为了执行代码，需要提供一个供代码执行的环境，所以会在内部创建一个执行上下文栈（ECStack），又称为执行环境栈、栈内存。
- **全局执行上下文（Global Execution Context）：** 为了确保全局代码能够正常的执行，V8引擎创建了全局执行上下文（GEC），**它会被放到ECS中执行**（它包含两部分内容）。
  - 为全局执行上下文创建一个关联的**变量对象（variable object）**，会将**全局定义的变量、函数**等都加入到Global Object（GO）中，但并不会赋值，此时一般为 undefined；（包含变量、函数的作用域提升）
  - 代码执行块，对变量赋值，执行其他函数等；
- **变量对象（variable object）：** 在每个上下文都会创建一个VO对象，去关联当前上下文中的变量和函数。
  - 如果当前上下文是全局执行上下文，VO指向**全局变量对象GO**；
  - 如果当前上下文是函数/私有执行上下文，VO指向**函数的AO对象**；

> 在代码执行阶段，**会创建一个执行上下文栈（ECS），紧接着会创建全局执行上下文（GEC），把全局执行上下文压入到执行栈中，在全局执行上下文中创建一个VO对象，将它关联到全局变量对象GO，该赋值的赋值**

过程如图所示：

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5uuvxrk6qj216s0pqq4w.jpg" style="zoom:45%;" />
:::


### 全局里遇到函数的执行过程

全局里有函数执行的情况下，一般会有三个步骤：
1. 代码编译
2. 代码执行
3. 根据实际情况确认当前上下文是否出栈释放

假如全局中有函数执行：

```JS
var name = 'jason';

foo(123);
function foo(num) {
  console.log(m);
  var m = 10;
  var n = 20;
  console.log('foo');
}
```

#### 1. 代码编译阶段

如果在代码编译阶段，在全局发现了创建函数，则会开辟一块堆内存（十六进制的内存地址：AAAFFF111）叫作**函数堆内存**。它包含两部分：
- **声明函数的作用域[[scope]]：** 一般是父级作用域 parent scope；
- **函数的执行体（代码块）：** 是一堆字符串；

上面就是创建函数包含的几个步骤，创建之后会把函数堆的地址放在调用栈中执行。

#### 2. 代码执行阶段

到了代码执行阶段，轮到了执行函数，会**根据函数体形成一个全新的私有上下文（函数执行上下文）**，简称“FEC”，并且压入到**EC Stack**中。

同时也会在函数执行上下文中生成一个存放私有变量的变量对象AO，这个AO对象也会在堆内存里开辟空间，来存储函数执行上下文中声明的变量，并将它们关联起来。代码执行代码，该赋值的赋值。

在私有上下文（函数执行上下文）里包含三部分内容：
- 在解析函数成为AST树结构时，会创建一个Activation Object（AO）对象：
  - AO中包含**形参/arguments/function/变量**
- **作用域链：** 由VO（在函数中就是AO对象）和父级VO组成，查找时会一层层查找；
- **this绑定的值：** 后续讲解；

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5vkda40gdj20do07emxg.jpg" style="zoom:50%;" />
:::


过程如图所示：

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5vk66ddw9j21720qqacm.jpg" style="zoom:40%;" />
:::

在执行函数体代码，查找私有上下文中的变量时，涉及到**作用域链的查找规则**。

#### 3. 判断当前上下文是否出栈释放

为了保证栈内存的大小合理利用，一般情况下，如果当前函数执行产生的上下文，在进栈且代码执行完成后，会把函数产生上下文移除栈（上下文存储的私有变量也随之消失）。

**全局上下文是在打开页面生成的，同理也需要在关闭页面的时候释放调（只有关闭页面时候才会被释放）**


**特殊情况：** 只要当前上下文中的某些内容，被上下文以外的东西占用，那么当前上下文是不能被释放的，上下文存储的变量等信息也随之被保留下来，这种情况也称为<mark>闭包</mark>。

#### 作用域的查找机制

在代码执行中，遇到一个变量，首先看一下是否为自己的私有变量：
- 如果是自己的私有变量，接下来所有操作都是私有的（和外接没有直接的联系）；
- 如果不是自己私有的，则按照scope-chain，向上级上下文中查找（如果是上级私有的，接下来的操作都是操作上级上下文中的变量）...一直找，直到找到EC(G)为止；

### 函数嵌套的执行过程

假如全局中有嵌套函数执行，来看下面👇🏻这段代码：
```JS
var message = 'Hello Global'

function foo() {
  console.log(message);
}

function bar() {
  var message = 'Hello Bar';
  foo();
}

bar();
```

乍一看，输出的 message 在 foo 函数里，而 foo 函数在 bar 函数作用域里执行，所以应该输出 "Hello Bar"，这就大错特错了。<mark>凡是涉及到函数嵌套关系的，变量的取值不是和它距离最近的那一个，也不是和它外层函数的调用位置有关，而是和当前函数上下文的定义位置有关</mark>。

过程如图所示：

::: center
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h5vx1jvlntj21do0ro78h.jpg" style="zoom:50%;" />
:::

### 变量环境和记录

其实上面说的是基于早期ECMA的版本规范

> 每一个执行上下文会被关联到一个变量对象（variable object，VO）中，在源代码中的变量和函数声明会被作为属性添加到VO中。
> 对于函数来说，参数也会被添加到VO中。

在最新的ECMA的版本规范中，对于一些词汇进行了修改：

> 每一个执行上下文会关联到一个变量环境（VariableEnvironment）中，在执行代码中变量和函数的声明会作为**环境记录**（Environment Record）添加到变量环境中。
> 对于函数来说，参数也会被作为环境记录添加到变量环境中。

通过上面的变化可以知道，在最新的ECMA标准中，变量对象VO，已经有了另一个称呼了叫变量环境VE。

