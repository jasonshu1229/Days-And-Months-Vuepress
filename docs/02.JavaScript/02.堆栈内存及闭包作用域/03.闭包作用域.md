---
title: 闭包作用域
date: 2022-08-31 22:10:43
permalink: /pages/2031fa/
---

## 闭包

> **来自红宝书的定义：**

匿名函数经常被人误认为是闭包。**闭包**指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中产生的。

> **来自MDN对JavaScript闭包的解释：**

一个函数和对其周围状态（词法环境）的引用捆绑在一起（或者说函数被引用保卫），这样的组合就是**闭包**。
- **闭包**让开发者可以在一个内层函数中访问到其他外层函数的作用域；
- 在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；

> **来自《你不知道的JavaScript》里的解释：**

当函数可以被记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行的。

接下来看一段代码，清晰地展示了闭包：

```js
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();
baz(); // 2 这就是闭包的效果
```

函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当做一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。

bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。

**bar()** 依然持有对 foo() 作用域的引用，而这个引用就叫作**闭包**。

可见闭包是由两部分组成的。

### 个人理解的闭包

<mark>一个普通的函数function，如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包</mark>。

- 闭包首先是一个函数；
- 其次它可以访问外层作用域的自由变量；

### 闭包的其它理解

它也是函数运行时候所产生的的机制，函数执行会形成一个全新的私有上下文，可以保护里面的私有变量和外界互不干扰。

函数执行形成一个私有的上下文，如果当前上下文的私有变量，有被外界所占用，那么当前私有上下文就不能出栈释放，自然而然里面的私有变量被保存保护起来了，不被外界干扰，操作里面的变量**不会影响外界**，这种机制叫**闭包**。

### 图解闭包的执行过程

<center><img src="https://s2.loli.net/2023/03/16/3sDia154dNTnG6o.png"/></center>

上图虽然展示了闭包函数的执行过程，但完全没有体现出闭包的性质特点。

函数执行结束之后

<mark>函数执行完毕之后，baz() 销毁，进而导致 bar() 函数销毁，所以 bar() 的上下文和变量对象都会被销毁</mark>（可对照上面的流程图发现执行上文和变量对象均被销毁）。

最终的流程如图所示：

<center><img src="https://s2.loli.net/2023/03/16/YGEWD7QFaJbZHVI.png"/></center>

### 闭包的内存泄漏

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以自然地考虑对其进行回收。

<mark>而闭包的神奇之处正是可以阻止这件事情的发生</mark>。事实上 foo() 内部作用域依然存在，因为在 bar() 函数内依然持有对该作用域的引用，在查找 **变量a** 的时候会先在 bar() 自己的AO对象中查找，找不到，则会通过作用域链找到 **parentScope** 中的 foo 变量对象，而这个引用就叫作闭包。

所以我们常说的闭包会造成的内存泄漏，其实就是指作用域链中的 foo() 变量对象AO 地址没有办法在堆内存中被释放。

### 合理解决内存泄漏

将 baz() 的指针指向 null，就不对 foo 对象有引用，那么 foo 对应的 AO 对象就不可达了。在下一次的GC的检测中，它们就会被销毁掉。

```JS
baz = null;
```

当 baz 赋值为 null 后，会发生什么，如图所示：

<center><img src="https://s2.loli.net/2023/03/16/aHtjN5Seo8BTyfu.png"/></center>

```JS
baz = null;
foo = null;
```

如果希望内存彻底干净的话，也可以把 foo 赋值为 null。

<center><img src="https://s2.loli.net/2023/03/16/bekTrRhFEfmMuJv.png"/></center>

## 闭包的利弊

大量应用闭包肯定会导致内存的泄漏，但是闭包的保护作用还是在实际开发中有很多帮助。

## 闭包的应用：

- 高阶编程：柯理化/惰性函数/componse函数/释放不释放/垃圾回收机制
- 源码分析：JQ/Lodash/React(Redux/高阶组件/Hooks)
