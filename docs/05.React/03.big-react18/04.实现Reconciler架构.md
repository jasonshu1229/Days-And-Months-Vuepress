---
title: 实现Reconciler架构
date: 2023-03-19 15:33:45
permalink: /pages/96bf34/
---

## 前言

通过上一篇文章的学习，了解了`Fiber`是什么，知道了`Fiber`节点可以保存对应的`DOM节点`。`Fiber节点`构成的`Fiber Tree`会对应`DOM Tree`。

前面也提到`Fiber`是一种新的调和算法，那么它是如何更新`DOM节点的`呢？

## 单个节点的创建更新流程

对于同一个节点，比较其`ReactElement`与`FiberNode`，生成`子FiberNode`。并根据比较的结果生成不同标记（插入、删除、移动...），对应不同宿主环境API的执行。

<center><img src="https://s2.loli.net/2023/03/19/d6TJzty4HDe27po.png" width="800px" /></center>

根据上面的Reconciler的工作流程，举一个例子：

比如，挂载`<div></div>`

```js
jsx("div");  // React Elment <div></div>

null  // 生成对应的 fiberNode，由于是挂载阶段，React还未构建组件树

生成子 fiberNode

Placement // 生成对应标记
```

将`<div></div>`更新为`<p></p>`

```js
jsx("p"); // React Element <p></p>

FiberNode {type: 'div'}; // 对应fiberNode

生成子fiberNode

// 对应标记
Delement Placement
```

用一张图解释上面的流程：

<center><img src="https://s2.loli.net/2023/03/19/cCdaEmirp27WPJ8.png" width="800px" /></center>

当所有的`ReactElement`比较完后，会生成一颗`fiberNode Tree`，一共会存在两棵`fiberNode Tree`

- **current**：与视图中真实UI对应的`fiberNode`树；
- **workInProgress**：触发更新后，正在`reconciler`中计算的`fiberNode Tree`（用于下一次的视图更新，在下一次视图更新后，会变成`current Tree`）；

这就是React中的"双缓存树"技术。

## 什么是"双缓存"？

双缓存技术是一种计算机图形学中**用于减少屏幕闪烁和提高渲染性能**的技术。

就好像你是一个画家，你需要在一个画布上绘制一幅画。在没有双缓存技术的情况下，你会直接在画布上作画。当你绘制一条线或一个形状时，观众会立即看到这个过程。如果你的绘画速度较慢，观众可能会看到画面的闪烁和变化，这会导致视觉上的不舒适。

引入双缓存技术就好比你有两个画布：一个是主画布，观众可以看到它；另一个是隐藏画布，观众看不到它。在这种情况下，你会在隐藏画布上进行绘画。当你完成一个阶段性的绘制任务后，你将隐藏画布上的图像瞬间复制到主画布上。观众只能看到主画布上的图像，而看不到隐藏画布上的绘制过程。这样，即使你的绘画速度较慢，观众也不会看到画面的闪烁和变化，从而获得更流畅的视觉体验。

使用双缓存技术时，计算机会在一个**隐藏的缓冲区（后台缓冲区）上进行绘制**，然后**将绘制好的图像一次性复制到屏幕上（前台缓冲区）**。这样可以减少屏幕闪烁，并提高渲染性能。

这种**在内存中构建并直接替换**的技术叫作[双缓存](https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2)。

React 中使用"双缓存"来完成`Fiber Tree`的构建与替换，对应着`DOM Tree`的创建于与更新。

## 双缓存Fiber树

`Fiber`架构中同时存在两棵`Fiber Tree`，一颗是"真实UI对应的 `Fiber Tree`"可以理解为**前缓冲区**。另一课是"正在内存中构建的 `Fiber Tree`"可以理解为**后缓冲区**，这里值宿主环境（比如浏览器）。

当前屏幕上显示内容对应的`Fiber树`称为`current Fiber树`，正在内存中构建的`Fiber树`称为`workInProgress Fiber树`。

`current Fiber树`中的Fiber节点被称为`current fiber`，`workInProgress Fiber树`中的`Fiber节点`被称为`workInProgress fiber`，他们通过`alternate`属性连接。

双缓存树一个显著的特点就是两棵树之间会互相切换，通过`alternate`属性连接。

```js
currentFiber.alternate === workInProgressFiber;
workInProgressFiber.alternate === currentFiber;
```

### 双缓存树切换的规则

`React`应用的根节点通过`current指针`在不同Fiber树的`HostRootFiber根节点`（ReactDOM.render创建的根节点）间切换。

即当`workInProgress Fiber树`构建完成交给`Renderer`渲染在页面上后，应用根节点的`current指针`指向`workInProgress Fiber树`，此时`workInProgress Fiber树`就变为`current Fiber树`。

每次状态更新都会产生新的`workInProgress Fiber树`，通过`current`与`workInProgress`的替换，完成DOM更新。

> Renderer 是一个与特定宿主环境（如浏览器 DOM、服务器端渲染、React Native 等）相关的模块。Renderer 负责将 React 组件树转换为特定宿主环境下的实际 UI。从而使 React 能够在多个平台上运行。

接下来，我们分别从 mount（首次渲染）和 update（更新）两个角度讲解 Fiber 架构的工作原理。

## mount 时 Fiber Tree的构建

mount 时有两种情况：

1. 整个应用的首次渲染，这种情况发生**首次进入页面时**。
2. 某个组件的首次渲染，当 isShow 为 true时，Btn 组件进入 mount 首次渲染流程。

```jsx
{isShow ? <Btn /> : null}
```

假如有这样一段代码：

```jsx
function App() {
  const [num, add] = useState(0);
  return (
    <p onClick={() => add(num + 1)}>{num}</p>
  )
}

const root = document.querySelector("#root");
ReactDOM.createRoot(root).render(<App />)
```

mount 时上面的`Fiber树`构建过程如下：

1. 首次执行`ReactDOM.createRoot(root)`会创建`fiberRootNode`；
2. 接着执行到`render(<App />)`时会创建`HostRootFiber`，实际上它是一个`HostRoot节点`；

> **fiberRootNode** 是整个应用的根节点，**HostRootFiber** 是 **\<App />** 所在组件树的根节点

3. 从`HostRootFiber`开始，以DFS（深度优先搜索）的的顺序遍历子节点，以及生成对应的`FiberNode`；
4. 在遍历过程中，为`FiberNode`标记"代表不同副作用的 flags"，以便后续在宿主环境中渲染的使用；

在上面我们之所以要区分`fiberRootNode`和`HostRootFiber`是因为在整个React应用程序中开发者可以多次多次调用`render方法`渲染不同的组件树，它们会有不同的`HostRootFiber`，但是**整个应用的根节点只有一个**，那就是`fiberRootNode`。

执行 ReactDOM.createRoot 会创建如图所示结构：

<center><img src="https://s2.loli.net/2023/03/20/NY27KoAQEFfmPsr.png" width="600px" /></center>

### mount 首屏渲染阶段

由于是**首屏渲染**阶段，页面中还没有挂载任何`DOM节点`，所以`fiberRootNode.current`指向的`HostRootFiber`没有任何`子Fiber节点`（即`current Fiber树`为空）。

当前仅有一个`HostRootFiber`，对应"首屏渲染时只有根节点的空白画面"。

```html
<body>
  <div id="root"></div>
</body>
```

### render 生成workInProgress阶段

接下来进入`render阶段`，根据组件返回的`JSX`在内存中依次构建创建`Fiber节点`并连接在一起构建`Fiber树`，被称为`workInProgress Fiber树`。

在构建`workInProgress Fiber树`时会尝试复用`current Fiber树`中已有的`Fiber节点`内的属性，（在首屏渲染时，只有`HostRootFiber`），也可以理解为首屏渲染时，它以自己的身份生成了一个`workInProgress 树`只不过还是`HostRootFiber`（`HostRootFiber.alternate`。

基于DFS（深度优先搜索）依次生成的`workInProgress节点`，并连接起来构成`wip 树`的过程如图所示：

<center><img src="https://s2.loli.net/2023/03/20/i5yoUbKc4HETWLM.png" width="600px" /></center>

上图中已构建完的`workInProgress Fiber树`会在`commit阶段`被渲染到页面。

### commit 阶段

等到页面渲染完成时，`workInProgress Fiber树`会替换之前的`current Fiber树`，进而`fiberRootNode`的`current`指针会指向新的`current Fiber树`。

完成双缓存树的切换工作，曾经的`Wip Fiber树`变为`current Fiber树`。

过程如图所示：

<center><img src="https://s2.loli.net/2023/03/20/2T8pAihNVYsdawm.png" width="600px" /></center>

## render 阶段的流程

文章的标题叫实现`Reconciler架构`，可全篇没有提`Reconciler`，是因为之前一直在用理论讲它里面最核心的双缓存树构建`Fiber`树阶段。

接下来，我们来看看用原理，在源码中它是如何实现的。

`Reconciler`工作的阶段在 React 内部被称为 render 阶段，ClassComponent 的render函数、Function Component函数本身也都在 render 阶段被调用


