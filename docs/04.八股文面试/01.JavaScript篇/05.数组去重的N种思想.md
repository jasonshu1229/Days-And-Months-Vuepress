---
title: 数组去重的N种思想
date: 2020-09-07 11:49:55
permalink: /pages/aaad0c/
tags: 
  - 
---
## 编者荐语：

在前端面试中，手写`flat`和手写数组`去重`是非常基础的面试题，通常出现在笔试或者第一轮面试中，主要考察面试者基本的手写代码能力和`JavaScript`的基本功。

今天就带大家从0了解`flat`特性到手写实现`flat`和数组`去重`的N种思想，再到接住面试官的连环追问中重新学习一遍`数组去重和扁平化`的技巧。

## 数组去重的几大思想

思想一：ES6，`Set`去重

思想二：基于`indexOf/includes`判断数组内是否存在重复元素 【操作的都是原数组】

思想三：新容器存储思想——对象键值对

思想四：先排序，再相邻比较（基于正则）

PS：大家在面试的时候可以先和面试官解释，我们分别用过哪几种思想实现它，再为面试官分别解释它们写法的优劣，相信通过这两道面试题，足以让面试官对你好感倍增！

## 思想一：Set

提到数组去重，我们大多数人首先想到的是`Set`去重

```js
let setObj = new Set(arr); // Set(5) { 12, 23, 15, 25, 16 } 得到的是 set的实例对象
let newArr = Array.from(setObj); // [ 12, 23, 15, 25, 16 ]
console.log(newArr); // [ 12, 23, 15, 25, 16 ]
```

但是有些ES6方法，在早些浏览器是不兼容的，那我们来看看下面几个数组去重的思想

## 思想二：indexOf

思想二，大概有三个不同的方法，每个方法的写法自然也就不同，

但它们的思想都是相同的：**遍历数组依次取得当前项和后面的项作比较，重复的项删除掉**

#### 【方法1】：当前项和后面项比较，重复则用splice删除

过程：遍历数组，取出当前项和后面的元素相比较，如果数组后面的元素包含当前项，则用`splice()`方法删除当前项

#### 需要注意的几点事项：

> 1. 遍历数组取当前项和后面比较的时候，不用取到数组最后一项，因为数组最后一项后面没有其它元素（故遍历数组元素，遍历到`arr.length - 1`时就好了）
> 2. 用`splice()`删除重复项的时候，会造成`数组塌陷`问题，应删除后及时`i--`，防止数组下标因数组长度变化产生差异

**【补充】数组塌陷现象**

>​	在对数组进行操作的时候，会使数组的长度产生变化，同时操作的数组那个项的下一个索引会被跳过，从而造成数组的某项会被跳过，这种叫做数组塌陷现象

比如来看下面的例子：

```js
let arr = [12, 23, 12, 15, 25, 23, 16, 25, 16];

for(let i = 0; i < arr.length - 1; i++) {
  let item = arr[i]; // 取得当前数组中的每一项
  let remainArgs = arr.slice(i+1); // 从 i+1项开始截取数组中剩余元素，包括i+1位置的元素
  if (remainArgs.indexOf(item) > -1) {
    // 数组的后面元素 包含当前项，应该把当前项删除掉
    arr.splice(i, 1); // 从索引为i的位置，删除一个元素
  }
}

console.log(arr); // [ 23, 12, 15, 23, 25, 16 ]
```

明显看出上面代码是有问题的，给大家画图解释一下：

从下图中和输出的数组可以分析出，`23`这个重复元素并没有被删除掉，它的原因就是因为`数组塌陷`问题导致数组长度更新，下标出现差异化，具体原因如下图：

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gieips2gctj30n70mcwhu.jpg)

所以解决办法，应该及时`i--`

完整版代码如下：

```js
let arr = [12, 23, 12, 15, 25, 23, 16, 25, 16];

for(let i = 0; i < arr.length - 1; i++) {
  let item = arr[i]; // 取得当前数组中的每一项
  let remainArgs = arr.slice(i+1); // 从 i+1项开始截取数组中剩余元素，包括i+1位置的元素
  if (remainArgs.indexOf(item) > -1) {
    // 数组的后面元素 包含当前项，应该把当前项删除掉
    arr.splice(i, 1); // 从索引为i的位置，删除一个元素
    i--;
  }
}

console.log(arr); // [ 12, 15, 23, 25, 16 ]
```

但是方法1，性能会不好，假设数组有一万个元素，当前项一旦删除，后面索引都要变。

#### 【方法2】：重复项用null替代，最后统一过滤

> 流程：遍历数组当前项和后面项比较，如果当前项和后面项重复，则把当前项赋值为`null`，最后过滤数组

> 弊端：需要对数组进行过滤等二次操作

实现代码如下：

```js
let arr = [12, 23, 12, 15, 25, 23, 16, 25, 16];

for(let i = 0; i < arr.length - 1; i++) {
  let item = arr[i]; // 取得当前数组中的每一项
  let remainArgs = arr.slice(i+1); // 从 i+1项开始截取数组中剩余元素，包括i+1位置的元素
  if (remainArgs.indexOf(item) > -1) {
    // 数组的后面元素 包含当前项，把当前项赋值 null
    arr[i] = null; // [null, null, 12, 15, null, 23, null, 25, 16]
  }
}

arr = arr.filter(item => item !== null);
console.log(arr); // [ 12, 15, 23, 25, 16 ]
```

但是这个方法还有个不好，就是需要对数组进行二次操作。

那我们来看方法3

#### 【方法3】：数组最后一项元素替换掉当前项元素，并删除最后一项元素

>流程：
>
>- 遍历数组当前项和后面项比较，如果当前项和后面项重复
>
>- 则把数组最后一项移动到当前项位置，删除数组的最后一项
>- 为了防止`i++`，跳过从当前项比较时，应及时`i--`，目的：仍然从当前项开始比较

```js
let arr = [12, 23, 12, 15, 25, 23, 16, 25, 16];

for(let i = 0; i < arr.length - 1; i++) {
  let item = arr[i]; // 取得当前数组中的每一项
  let remainArgs = arr.slice(i+1); // 从 i+1项开始截取数组中剩余元素，包括i+1位置的元素
  if (remainArgs.indexOf(item) > -1) { // 数组的后面元素 包含当前项
    arr[i] = arr[arr.length - 1]; // 用数组最后一项替换当前项
    arr.length--; // 删除数组最后一项
    i--; // 仍从当前项开始比较
  }
}

console.log(arr); // [ 16, 23, 12, 15, 25 ]
```

画图分析：

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gieosm42kej30o9097mzn.jpg)

> 总结：
>
> ​	上面这三种方法的核心思想，都是`依次遍历数组当前项和后面的项作比较，重复的项就要删除掉`。
>
> ​	这三种方法都是操作的`原始数组`，不会涉及新的数组或新的容器等，节约内存

接下来，我们来分析一下另外的一种思想：

### 思想三：新容器存储思想——对象键值对

>流程：
>
>- 遍历数组中的每一项，向新容器中存储
> - 存储之前，看新容器中是否有存储过了，存储过了，删除当前项
> - 没存储过时，往新容器中添加数组中遍历的元素

> 思想：
>
> ​	把数组元素作为`对象属性`
>
> ​	通过遍历数组，`判断数组元素是否已经是对象的属性`，如果对象属性定义过，则证明是重复元素，进而删除`重复元素`

例如：

```js
let obj = { 10:10, 20:20, 25: 25 };
```

代码如下：

```js
let obj = {};
for (let i=0; i < arr.length; i++) {
  let item = arr[i]; // 取得当前项
  if (typeof obj[item] !== 'undefined') {
    // obj 中存在当前属性，则证明当前项 之前已经是 obj属性了
    // 删除当前项
    arr[i] = arr[arr.length-1];
    arr.length--;
    i--;
  }
  obj[item] = item; // obj {10: 10, 16: 16, 25: 25 ...}
}
obj = null; // 垃圾回收
console.log(arr); // [ 16, 23, 12, 15, 25 ]
```

### 思想四：相邻项的处理方案思想——基于正则

> 思想：先排序，再基于正则比较相邻项

> 流程：
>
> - 先将无顺序的数组排序，
> - 定义正则表达式的规则
> - 通过`String.prototype.replace()`获取正则捕获的内容
> - 把正则规则捕获的内容，处理后添加到新数组中

在正式写代码之前，看下面这段代码正则后输出什么内容：

```js
let arr = [12, 23, 12, 15, 25, 23, 16, 25, 16];

// 将数组按升序排列
arr.sort((a,b) => a-b); //  [12, 12, 15, 16, 16, 23, 23, 25, 25]
let arrStr = arr.join('@') + '@'; // 12@12@15@16@16@23@23@25@25@
let reg = /(\d+@)\1*/g; // \d: 任何数字   \d+@: 15@   \1:前一个分组内容重复出现  *: 0~无数次

/**
  * val：reg正则捕获的内容（有重复情况）12@12@ 
  * group1：分组捕获的内容的第一组内容 12@
*/
arrStr.replace(reg, (val, group1)=> {
	console.log(val, group1);
  /*
    12@12@ 12@
    15@ 15@
    16@16@ 16@
    23@23@ 23@
    25@25@ 25@
  */
}) 
```

从上面代码中可以得出，每次`group1`的内容就差不多使我们想要的东西了，只要去掉`@`即可。

接下来，看完整版代码：

```js
let arr = [12, 23, 12, 15, 25, 23, 16, 25, 16];

arr.sort((a,b) => a-b);
arrStr = arr.join('@') + '@';
let reg = /(\d+@)\1*/g,
    newArr = [];
arrStr.replace(reg, (val, group1) => {
 // newArr.push(Number(group1.slice(0, group1.length-1)));
 newArr.push(parseFloat(group1));
})
console.log(newArr); // [ 12, 15, 16, 23, 25 ]
```

## 本文总结

看完这篇文章的同学，可以在面试的时候分类，分思想给面试官描述，可以先说我用哪几种思想实现过，它们的写法又分别有什么不同。
